``` {r echo=FALSE, results="asis"}
## process with knitr:::knit2html("filename.Rmd")
## Nothing to see here ... move along
require("questionr", quietly=TRUE)
page <- questionr:::Page$new()
nav <- questionr:::NavBar$new()
cat(page$write_header())
```
`r I(nav$write_header("Functions in julia", ""))`

We see in this project how to easily create functions in
`julia`. In the following project we learn how to graph functions. 

For basic things creating a new function and plotting it is as familiar as this:

```j
f(x) = sin(3x^2 - 2x^3)
plot(f, 0, pi)
```

Really, you'd be hard pressed to make this any shorter or more
familiar.  Of course, not everything is this easy so there are still
things to learn (in particular, trying this at home won't actually
draw the plot!), but keep in mind that 90% of what we want to do in
these projects is really this straightforward.

Mathematically, a function can be viewed in many different
ways. An abstract means is to think of a function as a mapping,
assigning to each $x$ value in the function's domain, a corresponding
$y$ value in the function's range. With computer languages, such as
`julia`, the same holds, though there may be more than one argument to
the function and with `julia` the type of argument and the number of
arguments is consulted to see exactly which function is to be called.

Here we don't work abstractly though. For a mathematical function
(real-valued function of a single variable, $f: \mathbb{R} \rightarrow
\mathbb{R}$), we typically just have some rule for what the function
will do to $x$ to produce $y$, such as

$$
f(x) = \sin(x) - \cos(x).
$$

In `julia` there are a few different ways to define a function, we
start with the most natural one which makes it very simple to work
with such functions.



`r I(nav$add("Polynomials"))`

One of the most basic families of functions are the polynomial
functions, which include as special cases the very familiar constant
functions, linear functions and quadratic functions.

Let's look at the familiar _linear_ function to convert Fahrenheit into Celsius:

$$
f(x) = 5/9 \cdot (x - 32).
$$

That is we subtract $32$ then multiply by $5/9$

We can easily turn this into a function, simply by replacing the mathematical notation $\cdot$ with `*`:

```j
f(x) = (5/9) * (x - 32)
```

This defines a function object `f`. To evaluate `f` for a given value
of $x$ we simply use the familiar mathematical notation. Here we see
what Celsius is for "normal" body
temperature:

```j
f(98.6)
```

And the Celsius equivalent to the standard boiling point:

```j
f(212)
```


<i class="icon-eye-open"></i> <span class="label label-important">Calling a function</span>

Evaluating a function for a given value is also known in programming languages as "calling"
`f`. When we work with functions in `julia`, the distinction between
the function object and calling the function is important to keep
straight -- though not too hard to do. In mathematical notation, it is
sort of like the difference between writing $f$ -- as opposed to $f(x)$ --
to describe the function, the latter implying there is some $x$ to be
evaluated.


<i class="icon-eye-open"></i> <span class="label label-important">Numeric literals</span>

`Julia` provides the familiar notation above for simple functions. In
fact, for polynomials with numeric coefficients, one can even skip the `*`:

```j
g(x) = 2x^2 - 3x + 2
g(2)
```

The convention is that when variables are immediately preceded by a
numeric literal (and by immediately it is meant no spaces are in
between) `julia` will assume multiplication is intended. (This can
bypass the usual order of operations, e.g.  `5/9(x-32)` is not `5/9*(x-32)`.)

This can also used when simple parentheses are involved:

```j
k(x) = 2(x - 1)^2 + 3(x+1)
```

But won't work with expressions such as `(x+1)(x-1)`, as `julia` will
then think the first parenthetical pair is a function and try to call
it with a value of `x-1`.


<i class="icon-eye-open"></i> <span class="label label-important">Equations versus functions</span>

Mathematically we tend to blur the distinction between the equation

$$
y = 5/9 \cdot (x - 32)
$$

and the function

$$
f(x) = 5/9 \cdot (x - 32)
$$

As the graph of the function $f(x)$ is the same as the graph of the
equation $y=f(x)$. There is a distinction in `julia` as

```j
x = -40
y = 5/9 * (x - 32)
```

will evaluate the righthand side with the value of `x` bound at the
time of assignment to `y`, whereas

```j
f(x) = 5/9 * (x - 32)
f(72)				## room temperature
```

will create a function which is called with a value of `x` at a later
time. So the value of `x` defined when the function is created is not
important here (as `x` is passed in as an argument).


<hr/>


#### square roots and powers

The `^` symbol can be used for powers, as is common, though there are
also a few predefined powers, such as the square root through
`sqrt`. So, we have:


$$
f(x) = \sqrt{x} + x^{1/3}
$$

becomes:

```j
f(x) = sqrt(x) + x^(1/3)
```

For the fractional power, this shows the required
parentheses around `(1/3)` to ensure that division occurs before the
higher-precedence power operation (compare `2^1/3` to `2^(1/3)`).

There is also a `cbrt` function for the $1/3$ power. This behaves as
expected with negative numbers, whereas using `^` with negative real
numbers returns `NaN`.



#### rational functions

Rational functions are simply ratios of polynomial functions. Defining them is straightforward. E.g.,

$$
f(x) = \frac{x^2 - 2}{x - 2}
$$

becomes

```j
f(x) = (x^2 - 2)/(x-2)
```

Here, as with your calculator, it is important to remember to use
parentheses around the top and bottom expressions, as otherwise the
division operator will have higher precedence.


### Questions
`r I(page$new_problem(" polys ..."))`
`r I(page$new_problem(""))`
`r I(page$new_problem(""))`

<hr/>


`r I(nav$add("Mathematical functions", ""))`


Of course `julia` has readily available all the usual built-in functions found on a
scientific calculator, and many more. See section 1.4.3 in `julia`'s manual
(Mathematical Functions) and
http://docs.julialang.org/en/latest/stdlib/base/#mathematical-functions
of the official `julia` documentation for lists. Here we show how to
translate some basic math functions into `julia` functions:



#### trigonometric functions

$$
f(x) = \cos(x) - \sin^2(x)
$$

becomes 

```j
f(x) = cos(x) - sin(x)^2
```

The mathematical notation $\sin^2(x)$ is really just a shorthand for
the more cumbersome $(\sin(x))^2$, which is what `julia` must do, as
notation such as `sin^2(x)` to `julia` is not what is wanted here. 


If you want to work in degrees you can do so with the degree-based trigonometric functions:

```j
fd(x) = cosd(x) - sind(x)^2
```


#### inverse trigonometric functions

A mathematical definition like

$$
f(x) = 2\tan^{-1}(\frac{\sqrt{1 - x^2}}{1 + x})
$$

becomes

```j
f(x) = 2atan( sqrt(1-x^2) / (1 + x) )
```

This particular function is just an alternative expression for $\cos^{-1}$ using the arctan function, as seen here:

```j
f(.5) - acos(.5) ## nearly 0
```


The exponent in the inverse trigonometric functions is _just_
mathematical notation for the longer expression "arctan" or
"arccos". (It definitely is not a reciprocal.)  The `julia` functions
-- like most all computer languages -- abbreviate these names to
`atan`, `acos` or `asin`.




#### Exponential function

The math function

$$
f(x) = e^{-\frac{1}{2}x^2}
$$

Can be expressed as

```j
f(x) = e^(-(1/2)*x^2)
```

The value of $e$ is built-in to `julia`, but can be inadvertenly redefined. As
such, it would be safer practice to use the `exp` function, as in:

```j
f(x) = exp(-(1/2)*x^2)
```

There isn't much difference in use, but don't try to do `exp^(-(1/2)*x^2)`!


#### Logarithms

The mathematical notations for logarithms often include $\ln$ and
$\log$ for natural log and log base 10. With computers, there is
typically just `log` for natural log, or with an extra argument the
logarithm to other bases.

$$
f(x) = \ln(1 - x)
$$

becomes just
```j
f(x) = log(1 - x)
```

Where as, the base 10 log:

$$
f(x) = \log_{10}(1 + x)
$$

can be done through:

```j
f(x) = log(10, 1 + x)
```

where the *first* argument expresses the base. (Of course
`log(1+x)/log(10)` works too!) For convenience, `julia` also gives the
functions `log10` and `log2` for base 10 and 2 respectively.

If you don't like this, `julia` has the special functions `log10` and `log2` for you to use.


### Questions
`r I(page$new_problem("..."))`
`r I(page$new_problem("..."))`
`r I(page$new_problem("..."))`

<hr/>


`r I(nav$add("More complicated functions"))`


If you want to define a more complicated function, say one with a few
steps to compute, the alternate form for a function can be
used. Basically it has the form

```
function function_name(function_arguments)
  ...function_body...
end
```

The last value computed is returned unless the `function_body` contains a `return` call.

The following is a more verbose way to define $f(x) = x^2$:

```j
function f(x)
  return(x^2)
end
```

The line `return(x^2)`, could have just been `x^2` as it is the last (and) only line evaluated.


<span class="label label-warning">Example: many parts</span>

Imagine we have a complicated function, such as:

$$
 g(x) = \tan(\theta) x + \frac{32/k}{200 \cos\theta} x -
    \frac{32}{k} \log\left(\frac{200 \cos\theta}{200\cos\theta - x}\right).
$$

where $k$ is the constant 1/2 and $\theta=\pi/4$. To avoid errors in
transcribing, it can be be useful to break such definitions up into
steps. Here we note the repeated use of $200\cos(\theta)$ and $32/k$ in the defintion of $g(x)$,
so we give them the intermediate names of `a` and `b`:

```j
function g(x)
	 theta = pi/4
	 k = 1/2
	 a = 200*cos(theta)
	 b = 32/k
	 tan(theta)*x + (b/a)*x - b*log(a/(a-x))
end
```

From this, we can easily see that we would need to be concerned as $x$ approaches the value of `a`, as when $x \geq a$ the logarithm won't be defined.


<span class="label label-warning">Example: Hockey stick functions</span>

Here is a different example, where we define a "hockey stick"
function, a name for functions that are flat then increase linearly after some threshold.

A cell phone plane might cost one \$30 for the first 500 minutes of
calling and 25 cents per minute thereafter. Represent this as a
function of the number of minutes used.

Here we need to do one of two things depending if $x$ is greater or
less than $500$. There are different ways to do this, but we will use
and `if-else-end` statement, which has the following form:

```j
function cell_phone(x)
	 if x < 500
	   return(30.0)
	 else
	   return(30.0 + 0.25*(x-500))
	 end
end
```

To see what it would cost to talk for 720 minutes in a month, we have:

```j
cell_phone(720)
```

<i class="icon-eye-open"></i> <span class="label label-important">Subtlety</span> 

We return `30.0` above -- and not the integer `30` -- so that the
function always returns a floating point value and not an integer if
less than 0 and a floating point value if bigger. This can be
important when using the function later on. In general it is a good
programming practice to have functions return only one type of variable.


To see why we call the above function a "hockey stick" function we
make a quick plot:

```j
p = plot(cell_phone, 0, 1000)
```



<i class="icon-eye-open"></i> <span class="label label-important">Simple alternative to `if-else-end`</span>

One can use the so-called _ternary operator_ `a ? b : c` for simple
`if-else-end` statements as above. So this example could have been a
one-liner:

```j
cell_phone(x) = x < 500 ? 30.0 : 30.0 + 0.25*(x - 500)
```

### Questions



`r I(page$new_problem("Ternary operator"))`

Which of these definitions will be the equivalent of $f(x) = \mid x \mid$? (The `abs` function is already one):

```{r echo=FALSE, results="asis"}
choices <- c("`f(x) = x`",
	    "`f(x) = x > 0 ? x : 0`",
	    "`f(x) = x > 0 ? x : -x`"
	     )
ans <- 3
cat(page$radio_choice(choices, choices[ans],  inline=FALSE))
```



`r I(page$new_problem("Ternary operator"))`

The `sign` function returns $-1$ for negative numbers $1$ for positive
numbers and $0$ for 0. Which of these functions could do the same>

```{r echo=FALSE, results="asis"}
choices <- c("`f(x) = x/x`",
	    "`f(x) = x/abs(x)`",
	    "`f(x) = x > 0 ? 1 : (x < 0 ? -1 : 0)`"
	     )
ans <- 3
cat(page$radio_choice(choices, choices[ans],  inline=FALSE))
```



`r I(page$new_problem("T-mobile pay as you go"))`

T-Mobile has a pay as you go cell phone plan with the following terms:

* You pay $30 per month and this includes the first 1500 minutes or text messages combined.
* Each additional minute or message costs 13 cents.

Which of these functions will model this?


```{r echo=FALSE, results="asis"}
choices <- c("`f(x) = x > 30 ? 13*x + 1500 : 30`",
	    "`f(x) = x > 1500 ? 30 : 30 + 0.13*x`",
	    "`f(x) = x > 1500 ? 30 + .13(x-1500) : 30`"
	     )
ans <- 3
cat(page$radio_choice(choices, choices[ans],  inline=FALSE))
```


<hr/>


`r I(nav$add("Function algebra"))`

Functions can be added or subtracted, multiplied or divided, and
unlike numbers there is the additional concept of composition. These
operations allow us to think of more complicated functions as
comprised of simpler functions glued together through these various
operations.

One can easily use the standard notations within a function
definition. For example:

```j
j(x) = x^2
k(x) = log(1 + x)
f(x) = j(x) - k(x)
f(x) = j(x) * k(x)
f(x) = j(x) / k(x)
f(x) = j(k(x))
```

For example, does the order of composition matter? Well, let's see
that it does. That this is not $0$ indicates that composistion is not
_commutative_:

```j
j(k(2)) - k(j(2))
```



The above works with the functions after they have been called (after
putting in $x$). There are times where we want to work with just the
function objects themselves as functions. The basic operators `-`,
`+`, `*`, and `/` are not defined for this. However, there is a
composition operator. It is the `*` operator overloaded to do
something for functions:

```j
f(x) = (j * j ) (x)
f(2) - j(k(2))
```


<i class="icon-eye-open"></i> <span class="label label-important">Commutivity</span>

Even though we know composition is not commutative (i.e. $f(g(x)) \neq
g(f(x))$ in general), `julia` uses `*` for composition. With real
numbers multiplication is a commutative operation which might cause
confusion, as it isn't until later in your math education will you see
examples of non-commutative multiplication, e.g. matrix multiplication.


<i class="icon-eye-open"></i> <span class="label label-important">Power notation is composition</span>

The power notation for functions does composition, not powers. So
$f^2(x) = f(f(x))$ and not $(f(x))^2$. This gives more usefulness to
the notation, but can cause confusion with a common mathematical
abbreviation with trig functions. That is, these are not the same and
only the last does the mathematically equivalent thing for
$sin^2(pi/4)$

```j
x = 1
( (sin^2)(x), sin^2(x), sin(x)^2 )
```

(The middle one is a function, as `2(x)` has higher precendence than `sin^2`.)

If you don't like this, open
http://www.quotesvalley.com/images/06/sin-is-odious-to-me.jpg and
blame Gauss himself.

`r I(nav$add("Anonymous functions"))`

A common mathematical notation for a function that emphasizes the fact
that $f$ maps $x$ to some value $y$ involving the rule of $f$ is to
use an arrow as:

$$
x \rightarrow -16x^2 + 32x
$$


You can do the exact thing in `julia` to create a function:

```j
x -> -16x^2 + 32x
```

This expression creates a function object, but since we didn't bind it
to a variable it will be immediately forgotten. Such functions without
a name are known as _anonymous functions_. These can be super
convenient, as we will see later. For now, we see that we can use them
as an alternate means to simply define a function just by assigning
the value to a name:

```j
f1 = x -> -16x^2 + 32x
f1(1)
```

(Though, this is technically different than the function defined by
`f(x) = -16x^2 + 32x` and for this reason, the `f(x)` style is
used throughout the projects to assign a function name.)

<i class="icon-eye-open"></i> <span class="label label-important">Alternate to composition notation</span>

Usual function composition notation, e.g.:

$$
f \circ g(x)  \text{ or } f(g(x))
$$

has us read from inner to outer or right to left. Of course, this is a
bit unusual to the English-reading brain, though we can easily
compensate as needed.

The arrow notation is different, it allows chaining in a natural left
to right way. E.g., the function $f(x) = \sin(x^2)$ can be thought of
as:


```{r echo=FALSE}
op = par(no.readonly=T)
par(mai=c(0,0,0,0))
plot.new()
plot.window(xlim=c(0,9), ylim=c(0,2))
arrows(0,1,1,1); arrows(3,1,5,1); arrows(7,1,9,1)
delta = 0.1
polygon(c(1,3,3,1) + delta*c(1,-1,-1,1), c(0,0,2,2) + 5*delta*c(1,1,-1,-1), col="gray80")
polygon(4 + c(1,3,3,1) + delta*c(1,-1,-1,1), c(0,0,2,2) + 5*delta*c(1,1,-1,-1), col="gray80")
text(2,1, "x -> x^2")
text(6,1, "x -> sin(x)")
text(.25, 1.05, "x")
text(4.05, 1.05, "x^2")
text(7.95, 1.05, "sin(x^2)")
par(op)
```

(We take $x$, square it, then take the sine of that answer)

This uses the familiar analogy of a function as a black box with pipes
(arrows) connecting them in composition. While the arrow notation in `julia`
doesn't do composition, `julia`, like many computer languages, uses `|` as the
"pipeline" operator to mimic this. The above could be written as:

```j
x = 2
f(x) = x^2
x | f | sin
```

Or more directly:

```j
2 | f | sin
```

This isn't the most general way to call a function (it only works for
functions that take and return a single variable), but for some longer
compositions this style can be a more clear way to chain function
calls.

The subtlety is you write the function object (`sin`) after the pipe,
not an evaluated function such as `sin(x)`.


### Questions
`r I(page$new_problem("..."))`
`r I(page$new_problem(""))`
`r I(page$new_problem(""))`

<hr/>


`r I(nav$add("Multiple arguments", "functions with parameters"))`

In `julia` it is very common to have more than one argument for a
function. For example, we saw the `log` function can use a second
argument to express the base. Defining a function with more than one
argument is straightforward, we just separate them by commas.

For example, revisiting this function

$$
 g(x) = \tan(\theta) x + \frac{32/k}{200 \cos\theta} x -
    \frac{32}{k} \log\left(\frac{200 \cos\theta}{200\cos\theta - x}\right).
$$


Rather than define the values of $k$ and $\theta$ outside the function, we can pass in values
for these _parameters_ with this definition

```j
function g(x, theta, k)
	 a = 200*cos(theta)
	 b = 32/k
	 tan(theta)*x + (b/a)*x - b*log(a/(a-x))
end
```

If we wanted, we could then define a function with the same name `g`
using the default parameters:

```j
g(x) = g(x, pi/4, 1/2)
```

Passing in parameters has the big advantage of explicitly showing how
`julia` will find variables used within a function, as otherwise you
need to have an understanding of the _scoping rules_ in place.


When calling a function, `julia` consults its arguments to look up
which function definition to use. Here we have either:

```j
g(50)
```

Or

```j
g(50, pi/4, 1/2)
```

The answers are the same, but the actual `g` function called is not,
though the former just passes it's arguments down to the latter with
some default values.


#### Questions

`r I(page$new_problem("Transformations"))`

Which of these function definitions corresponds to shifting the function `f` to the right by `c` units and up by `d` units:


```{r echo=FALSE, results="asis"}
choices <- c(
	"`g(x, c, d) = f(c(x-d))`",
	"`g(x, c, d) = c + f(x-d)`",
	"`g(x, c, d) = d + f(x - c)`",
	"`g(x, c, d) = c + d(f - x)`"


	     )
ans <- 3
cat(page$radio_choice(choices, choices[ans],  inline=FALSE))
```



`r I(page$new_problem("Transformations"))`

Which of these definitions will lengthen the period of a periodic function $f$ by a factor of $c$?

```{r echo=FALSE, results="asis"}
choices <- c(
	"`g(x, c) = f(cx))`",
	"`g(x, c) = f(x/c)`",
	"`g(x, c) = c + f(x)`",
	"`g(x, c) = c * f(x)`"
	)
ans <- 2
cat(page$radio_choice(choices, choices[ans],  inline=FALSE))
```

`r I(page$new_problem("Wavelet transform"))`

The following transform of a function is at the core of wavelet theory:

```j
g(t, a, b) = (1/sqrt(a)) * f( ( t- b)/a )
```

If $f(x) = \sin(x)/x$ and $a=2$ and $b=1$ compute $g(0, 2, 1)$.


```{r echo=FALSE, results="asis"}
f = function(x)  sin(x)/x
g = function(t, a, b)  (1/sqrt(a)) * f( ( t- b)/a )
a = 2; b = 1
val = g(0, a, b)
cat(page$numeric_choice(val - .00001, val + .00001))
```





<hr/>


<i class="icon-eye-open"></i> <span class="label label-important">Technical note</span>

In `julia` there are really two types of functions: generic functions
and anonymous functions. A generic function is made when we do
something like

```j
g1(x) = sin(3x^2 - 2x^3)
```

Generic functions allow for _polymorphic_ behavior, a computer science
term for allowing different function definitions to be called based on
the number of and type of the arguments passed in. This allows us to
have two functions named `g`. In just the base language of `julia`
some commonly used function names have a lot of different
definitions. (E.g, the `show` function to display an item depends on
the type of the item and there are _many_ different types.)


An anonymous function is made when we do something like

```j
g2 = x -> sin(3x^2 - 2x^3)
```

For the most part the end user can't tell the difference:

```j
(g1(1), g2(1))
```

But, there are times when there will be an error, most commonly when you try to redefine a generic function as an anonymous function:

```j
g1 = x -> sin(2x^2)
```

Or vice versa. Basically, `julia` has assigned a certain function type
to that name and you can't change that type though you can change the
function's definition. We use the generic function approach in these
notes to define our named functions, as the basic notation so closely
mirrors the standard math notation.  Though in the examples we make
use of anonymous functions when we don't want to store the value and
we return anonymous functions in our (upcoming) functions to compute
derivatives.

<!--- Finish this off -->
`r I(nav$write_footer())`
`r I(page$write_footer())`

