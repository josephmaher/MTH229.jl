``` {r echo=FALSE, results="asis"}
## process with knitr:::knit2html("filename.Rmd")
## Nothing to see here ... move along
require("questionr", quietly=TRUE)
page <- questionr:::Page$new()
nav <- questionr:::NavBar$new()
cat(page$write_header())
```
`r I(nav$write_header("Graphing functions", "with julia"))`



The `julia` language is a new language and as such, certain design
decisions are still being made. One key one is the interface for
creating graphics. At this point there are at least three different
ones, and perhaps more will be generated before a dominant one is
arrived at. As such, we don't try to teach the details of any one of
them. That being said, we can do all we need with the `plot` function
from the `Gadfly` package.

`r I(nav$add("Gadfly", "plot"))`

Like many programming languages, `julia`
extends its core language with user-defined packages. We leverage the
`Gadfly` package for plotting. Installing packages is mostly
painless, though one needs to instruct `julia` to do so. For this we
have a few things to do, should it not already by done.

First, the `Gadfly` package must be installed. `Julia` has a built in
package manager to take care of these details.

Now, if you have never installed a package, you need to initialize
things. It is done through

```
Pkg.init()    ## this is only needed to be done once
```

Now we can install the `Gadfly` package:

```
Pkg.add("Gadfly")  ## This installs the package. It only needs doing once.
```


The above is done only one time to install the package. (There is an update feature too.) However, within each session you must first bring the package features into your workspace with the `using` command:

```j
using Gadfly, Compose
```

The latter lets us actually draw the graphic. If all goes well, that is it for `Gadfly`.


The most basic usage follows this pattern:

```
p = plot(function_object, from, to)
```

as in

```julia
p = plot(sin, 0, 2pi)
```

That creates -- but does not draw, or render, the graphic. For that we need another command. The `Gadfly` package uses `Compose` to create `svg` files.  To view these we can use a browser. This would be a two step process: save the file, load in the browser. To avoid this, we provide a function `orender` in the `TeachersHelpers` package.

First install that package if you haven't already
(`Pkg.add("TeachersHelpers")). Then "use" the package with

```j
using TeachersHelpers  ## or all on one line: using Gadfly, Compose, TeachersHelpers
```

Then viewing a plot is as easy as piping the output through `orender`:

```j
p = plot(sin, 0, 2pi)
orender(p)
```

Or in one line (our preferred style in these projects):

```j
plot(x -> exp(x) + exp(-x), -2, 2) | orender
```

The last two examples show the two styles you can use to specify the
function object. Either you have a name for the function, such as
`sin`, of 'f', and you use that. (With no `(x)`!) Or, you can use an
_anonymous function_, a very useful for one-off functions.



Here we demonstrate some more by plotting a simple polynomial

```j
f(x) = x^2 - 2x + 2
plot(f, -3, 3) | orender
```

Of the same function squared:

```j
plot(x -> f(x)^2, -3, 3) | orender
```

### Questions

`r I(page$new_problem("Make a plot of ..."))`

`r I(page$new_problem("Make a plot of ..."))`

<hr/>

`r I(nav$add("Rational functions", "asymptotes"))`

A rational function is nothing more than a ratio of polynomial
functions, say $f(x) = p(x)/q(x)$. The interesting thing about them is
the fact what there can be asymptotes of both a horizontal,
vertical and even slant nature. 

The vertical asymptotes require care when plotting, as the nieve style
of plotting where a collection points is connected by straight lines
can orender poor graphs when the scale of $y$ values get too large. As
well, the `plot` function does not handle cases where you get `NaN` or
`Inf` for an answer (values that can come up when division by 0 is possible).

Basically, a graphic is meant to explore features of a graph. It is
often not possible to explore all of them on one graph.
Some features that are identifiable by calculus concepts are:

* zeroes
* vertical asymptotes
* horizontal asymptotes (or even slant ones)
* relative maximum and minimum
* increasing and decreasing parts
* changes in inflection

For example, if you want to find zeroes of a function, you really
want to look areas of the graph where the $y$ values are close to
$0$. However, if you have a vertical asymptote on the same graph, the
$y$ values might also be asked to show very large of small
values. With only a finite number of pixels available, it is impossible to
easily do both.

What to do? Well, if you want to look at zeroes, avoid the
asymptotes. This is done simply by not plotting for those values of
$x$.

For example, the function $f(x) = 1/x$ has a big vertical asymptote at $0$. 

One can try a simple plot:

```j
plot(x -> 1/x, -3, 3) | orender
```

But no graph shows up, as the points chosen by `plot` will include 0. (It uses 251 evenly spaced points between `a` and `b` to evaluate the function, and in this symmetric case those points will include 0.)

You can work around this by using a non-symmetric interval with an irrational endpoint:

```j
plot(x -> 1/x, -2, pi) | orender
```



This _still_ looks really bad. In the absence of `Inf` and `NaN` values, the `plot` function just connects points, and we see it connects the biggest negative point, with the smallest positive one with a big straight line. We should be able to do better. For now, let's just draw the part for positive $x$:

```j
plot( x -> 1/x, 0 + eps(), 3) | orender
```

Here we see what happens to the asymptote. The scale of the $y$ values is huge -- from 0 to `4e15`.  We added a small amount to the left endpoint incase the function is not defined there, but this function takes the reciprocal of a small amount and makes it huge.  Clearly we need to really avoid the issue. It isn't hard -- just add a little bit more to $0$:


```j
delta = 0.1
plot( x -> 1/x, 0 + delta, 3) | orender
```

That's better. The choice of `delta=0.1` was made, as this value obviously gives 10 -- a reasonably sized number for this -- when $f(x)$ is applied. Other functions may have different choices.


// XXX How to do two functions with different domains!
// Now to do both parts at once. 
//
//
// ```
// delta = 0.1
// p = plot( x -> 1/x, -3, 0 - delta)
// plot(p, x -> 1/x, 0 + delta, 3) | orender
// ```

// That's better.

So, the solution is to back away from any asymptotes, a task which might take more than one graph.

<span class="label label-warning">Examples: Trig functions</span>

Let

$$
f(x) = \frac{5}{\cos x} + \frac{10}{\sin x}
$$

Estimate graphically the minimum value over $(0, \pi/2)$.

The domain comes from the fact that $\sin(0) = 0$ and $\cos(\pi/2) =
0$, so we will have asymptotes at each. A simple graph shows this:

```j
f(x) = 5/cos(x) + 10/sin(x)
plot(f, 0 + eps(), pi/2 - eps()) | orender
```

As typical with vertical asymptotes, we can't see finer features of
the graph when the asymptotes are drawn. To remedy, we again back off
from the boundaries. Since $\sin(x)$ behaves like $x$ near $0$, we pick
`delta = .1` again and expect a max near $100$.

```j
delta = 0.1
plot(f, 0 + delta, pi/2 - delta) | orender
```

With this, we see the minimum is near $y=20$.


### Questions
`r I(page$new_problem("  ..."))`
`r I(page$new_problem(""))`
`r I(page$new_problem(""))`

<hr/>

`r I(nav$add("Arrays"))`

When we learn how to make a graph, the "T" method is employed, so
called as we draw a "T" and fill in values. For example, a chalkboard
after the instructor shows how to plot $f(x) = x^2$ might have this
drawn on it:

```
x |  y
------
1 |  1
2 |  4
3 |  9
4 | 16
```

We would like to be able to mimic the following procedures:

* choose a collection of $x$ values
* create the corresponding $y$ values

As these are the steps done to create the ordered pairs for a plot.

We have seen how variables can be used to refer to a single value, but
we want to refer to more than one value now. A container for holding
such is an `Array`. Arrays are implemented in most all computer
languages, though the term can mean different things.  An "array" in
`julia` is more general than what we need for now. In general, an
array is a multidimension grid of values -- all of the same type
(integer, floating point, _functions_, ...). 

For us, we want one dimensional arrays. These can be easily
constructed in different ways.

<h4>Creating 1-dimensional arrays with []</h4>

One can directly create a 1-dimensional array with the `[]` syntax. For example, to put a sequence of numbers together we can do:

```j
[1, 2 , 3, 4, 5]
```

Or

```j
[1, 1, 2, 3, 5, 8]
```

These create "vectors." (Our printing display horizontally to save space, but this will appear vertically if done at the console.) Row vectors can be created by dropping the commas:

```j
[13 21 34 55]
```

We will use just column vectors. If you have a row vector, the transpose operator `'` will convert:

```j
[13 21 34 55]'
```

<h4>Creating arithmetic sequences</h4>

A basic set of numbers used in programming are the values `1`,`2`, ..., `n`. These are the simplest example of an _arithmetic progression_ or sequence, which in general can have steps of a different size than 1: 

$$
a, a + h, a+2h, a+3h, ..., a + nh
$$

It should be possible to specify these either by 

* the start and end points and the number of points employed
* the start and end points and step size. 

In `julia` the `linspace` function will the former and the range operator the latter. Here are 5 evenly spaced numbers from $0$ to $pi/2$:

```j
linspace(0, pi/2, 5)
```

A column vector is returned. 

<i class="icon-eye-open"></i> <span class="label label-important">Integer versus float</span>
One gotcha with `linspace` is when we use integer values to begin and end. Compare these two outputs:

```j
linspace(0, 3, 5)
```

and

```j
linspace(0, 3.0, 5)
```

The former returns integer values found by rounding, the latter is generally desired.

<h4>The range operator</h4>

The "range" operator, `:`, is used to specify a step size, like $h$ in
the definition above. To get values which step by 1 we simply specify
the start and end values:

```j
1:4
```

That isn't so impressive. The description `julia` uses to show this value is exactly how we defined it, but this range is specifying the values 1, 2, 3, 4. To see that, we can put inside an array:

```j
[1:4]
```

The range operator returns a `Range` object which internally is much more compact to store than the array. 


The range operator can also use a step size:

```j
a=0; b= 10; h=3
a:h:b
[a:h:b]
```

Notice, the value for `b` is treated as as suggestion, the range will stop without exceeding `b`.





The $x$ values for a plot are typically a sequence of increasing values from $a$ to $b$. We would generally like to be able to specify the number of values to plot. This makes `linspace` the go-to choice to use.  (Though `Gadfly` uses: `a:(b-a)/n:b`.)



### Questions
`r I(page$new_problem("  ..."))`
`r I(page$new_problem(""))`
`r I(page$new_problem(""))`

<hr/>
`r I(nav$add("Indexing"))`

A column vector has a natural sense of first, second, ..., the $n$-th element. This allows `julia` to refer to the values by index ($1$-based, unlike some other computer languages). So, if `x` is an array, `x[1]` is the first value in that array. One can extract and _assign_ values using indices. A simple example is:

```j
x = [2, 4, 6, 8]
x[1]
x[3]
```

There are some special values. The `end` value refers to the last ($n$th):

```j
x[end]
```

The $n$ can be returned by `length`:

```j
length(x)
```

A range object can be used for indices:

```j
x[1:3]
```

As can any other column vector (but not a row vector):

```j
x[ [ 1, 2, 3] ]
```

The value `end` can be used in a range when indexing:

```j
x[2:end]
```

(But not without, as you can see by typing `2:end` by itself.)



### Questions
`r I(page$new_problem("  ..."))`
`r I(page$new_problem(""))`
`r I(page$new_problem(""))`

<hr/>

`r I(nav$add("Mapping", "a function to multiple values"))`

To specify the $y$ values we wish to "map" the function `f` to each
$x$ value.  In `julia` there are many different ways to do this, we
list four.

1) **map:** The `map` function. In many areas of mathematics, one refers to a function as a "map" from the domain to the range. The implication is that the function takes all the $x$ values to the corresponding $y$ values at once (conceptually) and not one at a time. The `map` function will apply the function `f` to each value in the array `x`.

For example, let's look at the simple polynomial $f(x) = -16x^2 + 32x$. We define our `julia` function with:

```j
f(x) = -16x^2 + 32x
```

If we want to look at this function for $x$ values between $0$ and $2$ we might define the $x$ values with:

```j
x = linspace(0, 2.0, 5)
```

Then the `map` function will create the corresponding $y$ values:

```j
map(f, x)
```

The syntax of `map` requires a slight pause. Here we do not actually call the function `f`, as in `f(2)`. Rather, we pass the name of the function to the `map` argument -- and `map` calls the function for each value in the column vector `x` and returns a corresponding column vector.

2) **Comprehensions:** Mathematically we grow familiar with set notation. One way to describe the values $y$ we are talking about might be:

$$
\{ f(x): x \text{ in } [0, 2] \},
$$

where this is read the values $f(x)$ _for_ each $x$ in the interval $[0,2]$.

If we have used the discrete values `x` from `linspace` to replace the continuum of values in the interval $[0,2]$, then we can use a "comprehension" to create the set notation above. The syntax is similar:

```j
{f(x) for x in x}  ## or x = x
```

There are a few comments to make though. The above returns an array of type `Any`. We would really like to have this be a "float". This can be done a few ways:

a) by wrapping the entire thing in `float` (which coerces the values):

```j
float( { f(x) for x=x } )
```

b) By using square brackets instead of braces and declaring the type:

```j
Float64[f(x) for x=x]
```

Either way, perhaps `map` is less trouble. (For ranges it is just syntactic sugar, as a map is defined by a comprehension.)  Regardless, we use comprehensions going forward as they mirror a more familiar syntax and generalize to functions of more than one variable  nicely.

3) **Using a `for` loop:** The `for` loop is a very common pattern in computer programming. For speed reasons, some languages (e.g., `Matlab` and `R`) try to avoid for loops for a "vectorized" approach, but `julia` works well with `for` loops.

A `for` loop simply loops over each value in the iterable data vector
`x` giving it a temporary name as it goes. To use a `for` loop to create
the $y$ values requires several steps, but  importantly we need a
container to hold the new values. The `similar` function creates an array
of the same dimensions as `x` below (but fills it with nonsense):

```j
y = similar(x)
for i in 1:length(x)
   y[i] = f( x[i] )
end
```

The `for` loop ends with the `end` keyword. Here we loop over each index of `x` and assign to the corresponding `y` value `f(x[i])`.
      
Conceptually this is the opposite of `map` where we think of the function acting on the entire column vector `x`. Instead, we iterate one-by-one over the values of `x` saving the function values as we go.

In some languages for loops are avoided if possible, as they can be slower. As well, the can require extra bookkeeping, such as needing to allocate a container for the answers. That being said, in `julia` they are widely used for speed and storage reasons. As well, they are used when we need to refer to more than one index. An example of that is the following way to create a Fibonacci pattern from the formula $x_i = x_{i-1} + x_{i-2}$:

```j
x = [1,1]; n=10;
for i in 3:n
    push!(x, x[i-1] + x[i-2]) ## push! extends the vector x
end
x
```

4) **Vectorization:** Finally, we note that `julia` allows for "vectorization" of
values. That means, many functions work on an array all at once. Many
but not all:

```j
sin(x)
```

```j
x^2
```

The latter fails, whereas the `sin` function naturally returns the 5 values for `x`. The reason is the definitions of multiplication, division and powers are mathematically different for single numbers (scalars) than for column vectors, or more generally matrices. Like `MATLAB`, `julia` chose the simplest notation to do matrix multiplication, powers and division. To get element-wise operations, we _prefix_ the operator with a "dot", as in `.^`:

```j
x.^2
```

So, if we were to redefine our function $f(x)  = -16x^2 + 32x$ with:

```j
f(x) = -16x.^2 + 32x
```

Then we could have simply done:

```j
f(x)
```

Though this is easy to do, it is also rather tedious as putting in the
"dots" is for some reason not that intuitive, so mistakes are often made.

We do use this style to generate simple values, for example here we step
through some powers of $1/10$ without much fuss:

```j
(1/10).^(1:5)
```


### Questions
`r I(page$new_problem("  ..."))`
`r I(page$new_problem(""))`
`r I(page$new_problem(""))`

<hr/>

`r I(nav$add("Two functions at once"))`

Now that we know about arrays, we can use them to illustrate how to graph two (or more) functions at once over the same interval -- just make an array of functions and hand this off to `plot`.

For example, to graph both the sine and cosine function we have:

```j
plot([sin, cos], 0, 2pi) | orender
```


Or to compare the effects of a simple transformation:

```j
f(x) = x^2
g(x) = 4 + f(x-3)
plot([f, g], -4, 4) | orender
```

Not all pairs of functions will naturally appear on the same $x$ and $y$ axes, as the scale of them may be way off. Yet, you may still wish to compare them. With some work, one can stack figures vertically. Here is an example

```j
p1 = plot(x -> x^2 + 3x + 10, -4, 4)
p2 = plot(x -> 2x + 3, -4, 4)
vstack(render(p1), render(p2)) | orender
```

The last magic syntax makes it all work. Don't bother trying to figure out why, but tuck away in the back of your mind this possibility. 



### Questions
`r I(page$new_problem("  ..."))`
`r I(page$new_problem(""))`
`r I(page$new_problem(""))`

<hr/>

<!--- Finish this off -->
`r I(nav$write_footer())`
`r I(page$write_footer())`

