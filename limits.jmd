``` {r echo=FALSE, results="asis"}
## process with knitr:::knit2html("filename.Rmd")
## Nothing to see here ... move along
require("questionr", quietly=TRUE)
page <- questionr:::Page$new()
nav <- questionr:::NavBar$new()
cat(page$write_header())
```
`r I(nav$write_header("Investigating limits with julia", ""))`


The concept of a limit is what makes calculus possible. The formal
definition is difficult to appreciate, but very important to building
a firm foundation to build on. The intutitive idea of

$$
\lim_{x \rightarrow c} f(x) = L
$$



Is the idea that as $x$ gets "close" to $c$ then $f(x)$ should get
close to $L$. 


`r I(nav$add("Get close"))`


It is this idea we can approach with the computer, though we shall see
that on the computer there are limits to how close we can get to a
value.

The key to our analysis here is 

* defining how we get close to $c$
* imagining how $f(x)$ is getting close to some $L$ which may be unknown.

Let's look at a simple example, the limit of $f(x) = \sin(x)/x$ as $x$
approaches 0. Even though both $\sin(x)$ and $x$ are continuous
functions everywhere, the function is not continuous at $0$ due to
division by $0$. But does the function have a limit?

First, we note that this function is an even function, so if you are
being thorough and worrying about getting close from the left and the
right, you need only check one side.

Next, we define some values getting close to $0$:

```j
small_values = (1/10) .^ (1:16)
```

These are just powers of 1/10 approaching 0.

We can then just look at the values of $f(x)$:

```j
f(x) = sin(x)/x
out = [f(x) for x in small_values]
```

We can put the two arrays (`small_values` and the output together) to see a bit better, but we must coerce the `out` variable to floating point:

```j
[small_values float(out)]
```

This limit is clearly 1.


Another limit to look at is a variant of the derivative formula which emphasize the secant line aspect:

$$
\lim_{x \rightarrow c} \frac{f(x) - f( c)}{x-c}.
$$

Let's take $c = 1$ and $f(x) = x^x$. We have

```j
f(x) = x^x
```

But how do we get close to $c=1$? Well, we just add $c$ to our small values getting close to 0:

```j
c = 1
[f(x) for x in c + small_values]
```

This the right limit as we only looked at values bigger than $c$. A left limit is similarly done:
```j
[f(x) for x in c - small_values]
```

Here there is no difference, and we take the limit to be $1$.


<hr />

`r I(page$new_problem("Find the limit ..."))`

$(1+x)^{1/x}$

`r I(page$new_problem("Find the limit ..."))`


$log(1+x)/x$ (same)
`r I(page$new_problem("Find the limit ..."))`

`r I(page$new_problem("Find the limit ..."))`

(From Strang, attributed to Stein.)

Look at the figure:

```r
theta = pi/6
r = 1
plot.new()
plot.window(xlim=c(0,1), ylim=c(0,sin(theta)))
polygon(c(0, cos(theta), cos(theta)), c(0, 0, sin(theta)))

t = seq(0, theta, length=100)
polygon(c(cos(theta), 1, cos(t)), c(0, 0, sin(t)), col="gray")
text(.15 * cos(th(eta/2), .15 * sin(theta/2), "theta")
text(.5, 0, "1", pos=1)
```

Let $f(\theta)$ be the area of the triangle and $g(\theta)$ the shaded region. What is the limit 

$$
\lim_{\theta \rightarrow 0+} \frac{f(\theta)}{g(\theta)}?
$$



```{r echo=FALSE, results="asis"}
val <- 1
cat(page$numeric_choice(val - .000001, val + .000001))
```







`r I(page$new_problem("Some problem ..."))`
 right limit (x^x - 1)/x as x -> 0 -- issue!

<hr />




`r I(nav$add("Removable singularities", ""))`



Some limit problems come from a function with a removable
singularity. This means you can redefine the function at a point to make it continuous.
The example of $f(x) = \sin(x)/x$ is a good one. This
function is not defined for $x=0$. However, we can define it via
$f(0)=1$. As we saw this was the limit at 0. This will make $f$ a
continuous function, so $x=0$ is a removable singularity.

For functions with removable singularities a graph may not even show the issue. This is
because we ultimately represent a graph as nothing more than a
dot-to-dot plot and if those "dots" don't happen to include the
singularity, the graph won't see it.

To see how we could have guessed the limit graphically, we might have simply made:

```j
f(x) = sin(x)/x
plot(f, -pi, pi) | render
```

This graph shows no issues, as the point 0 is not included in the set
of `x` values representing the domain.

<i class="icon-eye-open"></i> <span class="label label-important">Inf and NaN</span>

Some computations end up being valid floating point values, but not
real numbers. These are `NaN` and `Inf`. We can make these numbers easily enough:

```j
(1/0, 0/0)
```

These more or less match what happens in the limit ($0/0$ is
indeterminate, $1/0$ is infinite, though we usuall have a sign,
e.g. $1/x$ at $0$. These values can be problematic when graphing. In
the example above we avoid these numbers, but this was just lucky. If
you aren't lucky, you can reset the domain to avoid such issues.

<hr />
`r I(page$new_problem("Some problem ..."))`

`r I(page$new_problem("Some problem ..."))`

`r I(page$new_problem("Some problem ..."))`

`r I(page$new_problem("Some problem ..."))`

<hr />

`r I(nav$add("Too close", ""))`

A related limit to $\sin(x)/x \rightarrow 0$ is that

$$
\lim_{x \rightarrow 0} \frac{1-\cos(x)}{x^2} = \frac{1}{2}.
$$

Related in that they are used to approximate related functions near
$0$ with $\sin(x) \approx x$ and $\cos(x) \approx 1 - (1/2) x^2$. A graphic shows the latter one:

```j
plot([cos, x -> 1-(1/2)x^2], -pi, pi) 
```

Note in the figure how the parabola tracks the shape of the cosine
function very well near $x=0$ but not far from $0$.


Numerically, we have a different story. We see that there are
limitations to our approach to finding limits that show up in
analyzing this.

Here is a first attempt:

```j
small_values = (1/10).^(1:16)
out = [(1-cos(x))/x^2 for x in small_values] 
[small_values float(out)]
```

We notice something odd -- the values ultimately become 0 when we just
said they should become $1/2$. Atleast for about the first half of the
output things look okay, but then something goes terribly wrong.

Let's look at the two pieces. First the denominator:

```j
[x^2 for x in small_values] 
```

There is nothing here to speak of. `Julia`'s `Float64` type follows
the IEEE 754 floating point standard. Of the 64 bits, 1 is used for
the sign (plus or minus) and 11 are used to store the exponent. (See
this informative blog post for more
http://www.johndcook.com/blog/2009/04/06/anatomy-of-a-floating-point-number/)
As $2^{11} = 2048$ roughly half are used for negative exponents, the
other half for positive exponents. The range is from `1e-1022` to
`1e1023`. We aren't even close the the lower range with `1e-32`.


Let's look at the numerator:

```j
[1-cos(x) for x in small_values]
```

The issue is the difference between $\cos(x)$ and 1. Let's look with the small values printed:

```j
[small_values float([1-cos(x) for x in small_values]) ]
```


In general, one rule of thumb with numeric computations is that if we
subtract two like-sized quantities our answer may have dramatically
reduced precision. 

In this specific case by the time we get to $10^{-8}$, the difference
between $\cos(x)$ and $1$ is looking to be around `5e-17`. However, in
floating point representation their are fundamental limits to how
close something can be. Of the 64 bits representing a number, 52 are
used for the precision. (A number, $s \cdot p \cdot 10^e$, is
represented with a sign, the precision and an exponent.) This puts the
restriction on what can be represented and ultimately gives a
granularity if one looks too closely.


The value

```j
eps()
```

measures how much larger the next representable number _after_ $1.0$ is from $1.0$. (Of
course, this has no answer in real numbers, but floating point is an
approximation.) 


What has happened with $1-\cos(x)$ is the mathematical value of
$\cos(x)$ gets too close to 1 when $x = 10^{-8}$ and so the difference
is treated as $0$ as the two numbers have the same representation.
Since 0 divided by any non-zero number is zero, we get the unusual
behavior.

So be careful, we can try and get to close when looking "close."


<i class="icon-eye-open"></i> <span class="label label-important">Investigating how numbers are represented in floating point: prevfloat</span>

`Julia` has some functions for working with floating point
numbers. Some of you might be thinking that since `eps` is the
difference to the next representable number larger than 1, what is the
same for the next representable number _less_ than one. The
`prevfloat` value gives this. Here we see the issue between 7 and 8:

```j
prevfloat(1.0) < cos(1e-7)
prevfloat(1.0) < cos(1e-8)
```

### Questions

`r I(page$new_problem("nextfloat"))`
is `eps == nextfloat(1.0)`?



```{r echo=FALSE, results="asis"}
choices <- c("No",
	     "Yes"
	     )
ans <- 2
comment <- setNames(list("Are you sure?"), choices[-ans])

cat(page$radio_choice(choices, choices[ans],  inline=FALSE))
```

`r I(page$new_problem("bits etc"))`

The `bits` function prints the bit representation of a number. For
real numbers, the first bit is the sign, the next 11 the exponent and
the last 52 are for the precision. Let's look at the values for a few:

```j
bits(cos(1e-7))
bits(cos(1e-8))
bits(1.0)
```

We see here how two have the same floating point representation.

For fun, what is the difference between `bits(-1.0)` and `bits(1.0)`?


```{r echo=FALSE, results="asis"}
choices <- c("The last bit on the right is different",
	     "The first bit on the left is different",
	     "The 2 through 12th bit (on the left) are all 1."
	     )
ans <- 2
cat(page$radio_choice(choices, choices[ans],  inline=FALSE))
```


`r I(page$new_problem("bits etc"))`

What is the difference between `bits(NaN)` and `bits(Inf)`? (These two are coded specially in floating point.)


```{r echo=FALSE, results="asis"}
choices <- c("The first bit on the right is different",
	     "Bits 2-12 are the same, but bit 13 differs, that's all",
	     "They are identical, both are not numbers"
	     )
ans <- 2
cat(page$radio_choice(choices, choices[ans],  inline=FALSE))
```

<hr/>


<span class="label label-warning">Some "unneeded" functions</span>

`Julia` has some functions which at first glance seem unneeded. For
example, take the case of the function $f(x)=\log(1+x)$. This is an important function,
and it is important to make sure it is as accurate as possible. A simple approximation to $\log(1+x)$ is just the value $x$. Let's see how accurate:

```j
small_values = (1/10).^(1:16)
[log(1 + x) - x for x in small_values]
```

Note towards the end, the difference starts to get unstable. The function `log1p` does nothing more than this problem more accurately:

```j
[log1p(x) - x for x in small_values]
```


### Questions

`r I(page$new_problem("Others"))`
Others expm1 does e^x - 1 as x goes to 0

<hr/>

`r I(nav$add("Limits at infinity", ""))`

The concept of a limit can be extended. For example, the concept of a
limit as $n$ goes to infinity for some sequence of values
parameterized by $n$.


Let's compute $\pi$ as the circumference of a circle of radius 1 by
approximating the circle by an inscribed regular polygon with $n$
sides. The legnth, $k$, of a given side is

$$
k = 2 \sin(\frac{2\pi}{2n})
$$

As can be seen by taking the isoceles triangle with angle $2\pi/n$ and
dropping a horizontal with opposite length 1/2 the entire length.


```{r echo=FALSE}
plot.new()
plot.window(xlim=c(-1,1), ylim=c(-1,1))
n <- 17
plot_circ = function(n, ...) {
  theta <- seq(0, 2*pi, length=n)
  x <- cos(theta); y <- sin(theta)
  lines(x, y, ...)
}
plot_circ(1000, col="gray")
plot_circ(n+1, col="black")

t <- 2*pi/17
lines(c(1, 0, cos(t)), c(0,0, sin(t)))
text(cos(t/2), sin(t/2), expression(k), pos=4)
```





Thus the total length is 

$$
l_n = n \cdot 2 \sin(\frac{2\pi}{2n})
$$

As $n$ goes to $\infty$ this should go to the circumference of the circle of radius 1 or $2\pi$.

Let's see.

```j
n_to_infinity = 10.^(1:16)
l(n) =  n * 2sin(2pi/(2n))
[l(n) for n in n_to_infinity]
```

To compare to $2\pi$ we can divide instead:

```j
[l(n)/(2pi) for n in n_to_infinity] 
```


There isn't much difference to the above than what we did before,
except we take increasing larger values for $n$, not values getting
close to 0 for $x$.


<!--- Finish this off -->
`r I(nav$write_footer())`
`r I(page$write_footer())`

