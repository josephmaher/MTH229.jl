``` {r echo=FALSE, results="asis"}
## process with knitr:::knit2html("filename.Rmd")
## Nothing to see here ... move along
require("questionr", quietly=TRUE)
page <- questionr:::Page$new()
nav <- questionr:::NavBar$new()
cat(page$write_header())
```
`r I(nav$write_header("Julia as a calculator", ""))`

The programming language `julia` is a new language (www.julialang.org)
that builds on a long history of so-called dynamic scripting languages
(DSLs).  DSLs are widely used for exploratory work and are part of the
toolbox of most all data scientists, a rapidly growing area of
employment. The language `julia` is reminiscent of is `MATLAB`, though
it offers many improvements over that language in terms of ease of use
and speed in some cases. (Well it should, `MATLAB` was started back in
the 70s.) Even better, `julia` is an open-source project which means
it is free to download and install, unlike the commercial package
`MATLAB`.

This class will use `julia` to explore calculus concepts. Unlike some
other programs used with calculus (e.g., Mathematica, Maple, and Sage)
`julia` is not a symbolic math language. Rather, we will use a numeric
approach. This gives a different viewpoint on the calculus material
supplementing that of the text book. Though there are a few
idiosyncrasies we will see along the way, for the most part the
`julia` language will be powerful and easy to learn.


`r I(nav$add("Starting with Julia"))`

In order to get started with `julia` it needs to be installed. If this
is not done already, you have a bit of work to do. Point your browser
to http://code.google.com/p/julialang/downloads/list to get a binary.


For some, installation for scratch is a good option. This allows you
to run the latest and greatest version without much fuss. To install
from scratch requires some command line tools that are readily
available for Linux and Mac OS X users, but not so for Windows
users. Details are available at https://github.com/JuliaLang/julia .


Starting `julia` varies amongst the different operating systems. All
have a _console_ where commands are typed for `julia` to interpret and
execute. This is known as the _command line_ and though a long
familiar means of interacting with computers, it is generally not
familiar to the average student. We will need to learn to like the
command line. Once done, you may think it is great, but it can a bit
frustrating getting to that attitude.

Here is what the command line looks like on startup from a mac book
pro within the terminal:


```
some-macbook-pro:julia verzani$ julia
               _
   _       _ _(_)_     |  A fresh approach to technical computing
  (_)     | (_) (_)    |  Documentation: http://docs.julialang.org
   _ _   _| |_  __ _   |  Type "help()" to list help topics
  | | | | | | |/ _` |  |
  | | |_| | | | (_| |  |  Version version_number
 _/ |\__'_|_|_|\__'_|  |  Commit github_commit and date
|__/                   |

julia> 
```

The command line is the last line: a prompt beginning with
`julia>`. Here is where you type an expression and then the
<em>enter</em> key to ask `julia` to evaluate it.




`r I(nav$add("The basics"))`

`Julia` can replicate the basics of a calculator with the standard
notations. The familiar binary operators are `+`, `-`, `*`, `/`, and
`^`. You basically type in the expression, and then press the <em>enter</em> or <em>return</em> key.

For example, to add two and two:

```j
2 + 2
```

Or to convert 70 degrees to Celsius with the standard formula $C=5/9(F-32)$:

```j
(5/9)*(70 - 32)
```

Of to find a value of $32 - 16x^2$ when $x=1.5$:

```j
32 - 16*(1.5)^2
```


To find the value of $\sqrt{15}$ we can use the power notation:

```j
15^(1/2)
```

<span class="label label-important">Using functions</span>

Or use the built-in _function_ `sqrt` to find the square root:

```j
sqrt(15)
```



In the last command, we see how to evaluate a function -- using its
name and parentheses, as in `function_name(arguments)`. Parentheses
are also used to group expressions, as used in the $1/2$ power
above. Additionally, they are also used to make "tuples", a concept we
don't pursue but that is important for programming with `julia`. The
point here is the context of how parentheses are used is important,
though for the most part the usage is the same as their dual use in your
calculus text.



Continuing, to find the energy of 10 units of mass from $E=mc^2$,
where $c = 3 \cdot 10^8$ meters per second can be done as:

```j
10 * 3e8^2
```

<span class="label label-important">scientific notation</span>

That `e` above is `julia`'s _scientific notation_ and stands for
$10^8$ above. This is different from the built in constant `e` (the
number `j e`). `Julia` uses scientific notation for expressions of the
type `#e#` for some numbers, where the first can be an integer or
number with a decimal point, but not the last, which is an integer.


For the above, one could be more verbose and evaluate:

```j
10 * (3 * 10^8)^2
```

Though the outputs appear different, we can see they are indeed the same by subtracting:

```j
10 * (3 * 10^8)^2 - 10*3e8^2
```

A difference of 0 indicates they represent the same number.

<span class="label label-important">Floating point and integers</span>

In fact though, to `julia` the two values above are not quite the same,
as one is stored as an integer, the other using floating point
arithmetic (ignore the `typeof` function for now, it just reports the storage type):

```j
typeof(3e8)
typeof(3 * 10^8)
```

The output shows not only are the two stored differently (floating
point versus integer), the number of bits used is also displayed. The
count on bits is important in technical computing, but can safely be
ignored for now, though it may differ from computer to computer, as
not all computers are 64 bit.

This difference between integer and floating point can be
subtle. There are some functions that expect floating point values, as
opposed to integer values. To specify a floating point value used in
place of an integer, use a decimal point:

```j
typeof(2)
typeof(2.0)
```


<span class="label label-important">Comparing values: when are numbers equal?</span>


In the above, we subtracted two values to see if they were equal.
Programming languages typically have a simple means to compare
values. In `julia`'s case, the `==` operator will do so:

```j
2 == 2
2 == 3
```

For our previous comparison we get equality
```j
3e8 == 3*10^8
```

This is because before the comparison is done, one type is promoted
(coerced) into the other before comparison. This behavior is generally desirable, as in this case the difference is in the storage type but not the number stored, as both are precise. If you want to get an exact comparison, the triple equals sign is available:

```j
3e8 === 3*10^8
```


In general though, with floating point values unexpected (at first
glance) comparisons occur. E.g., the value of `sqrt(2)` -- an
irrational number -- is truncated to fit into a floating point
notation and when squared the difference is non-zero:

```j
sqrt(2) * sqrt(2) == 2
```

This subtraction shows the two values differ, but not until the 16th
number after the decimal point:

```j
sqrt(2) * sqrt(2) - 2
```


The subtle differences between storage of numbers in floating point
will appear from time to time. For the most part, these are handled by
comparing values through a tolerance that says if they are close
enough we will consider them equal. A typical tolerance is given by
the square root of the `eps` values -- which depends on the number of
bits your computer has available. Here we have:

```j
eps() ^ (1/2)
```


### Questions
`r I(page$new_problem("Calculator problems"))`
`r I(page$new_problem("Calculator problems"))`
`r I(page$new_problem("Calculator problems"))`
<hr/>


`r I(nav$add("Rational Numbers"))`

In addition to special classes for integer and floating point values,
`Julia` has a special class for rational numbers, or ratios of
integers. To distinguish between regular division and rational
numbers, `julia` has the `//` symbol to define rational numbers:

```j
1//2
```

```j
typeof(1//2)
```


As you know, a rational number $m/n$ can be reduced to lowest terms by
factoring out common factors. `Julia` does this to store its rational
numbers:

```j
2//4
```

Julia will often silently convert one type to another, though not
always. When we subtract a floating point number from a rational number it does:

```j
1//2 - sqrt(5)/2
```

This leaves, a floating point number.

However, we can't do the following, as the numerator would be
non-integer when trying to make the rational number:

```j
(1 - sqrt(5)) // 2
```

`r I(nav$add("Keyboard shortcuts"))`

There are some keyboard shortcuts that are mostly standard with
command lines that can simplify your interactions:

* The up and down arrows. Command lines generally keep a _history_ of
  commands that you can scroll through. The up and down arrows allow
  you to easily do this. For searching past commands in the history,
  try typing `ctrl-r` and hitting a search expression.

* Editing a command. The command line does not allow editing of
  previously issued commands until they are copied (as above or other
  means) into the current line. Once in that line, you can move
  through the output with the left and right arrow keys (but maybe not
  the mouse!) These move one position over. The useful bindings
  `ctrl-a` to get to the start of the line and `ctrl-e` to get to the
  end are good to know.

* The commands `ctrl-k` will "kill" all the text to the right of the
  cursor. The "kill" is a little harsh, it actually stores the last
  killed command which may be retrieved (and inserted at the cursor)
  with `ctrl-y` (for yank).

* Other "emacs"-style bindings are present, but not described here.

`r I(nav$add("Order of operations"))`

In more complicated uses of the calculator it is often necessary to
properly use parentheses. For example to compute

$$
\frac{12 - 10}{2}
$$

We can not simply do

```j
12 - 10 / 2
```

But rather, use parenthesis in the numerator:

```j
(12 - 10)/2
```

The reason being the standard order of operations has division done
before subtraction yet our problem wants us to subtract before
dividing.

The standard order of operations is remembered by the mnemonic PEMDAS,
which can be misleading, so we spell it out here:

* Parentheses (`P`)
* Exponents (or powers) (`E`)
* Multiplication or Division (`MD`)
* Addition or Subtraction (`AS`)

This explains why we need $(12-10)/2$ above, as subtraction happens after division so without parentheses we would be computing $12 - (10/2)$.


### Questions
`r I(page$new_problem("Problems on P, E, MD, AS"))`
`r I(page$new_problem("Problems on P, E, MD, AS"))`
`r I(page$new_problem("Problems on P, E, MD, AS"))`
`r I(page$new_problem("Problems on P, E, MD, AS"))`
`r I(page$new_problem("Problems on P, E, MD, AS"))`
<hr/>



There is a little more to the story, as we need to understand what
happens when we have more then one operation with the same level. For
instance, what is $2 - 3- 4$? Is it $(2-3) - 4$ or $2 - (3 - 4)$. The
former is doing the same-level operations form left to right, the
latter from right to left. 

<div class="alert alert-info">
<strong>right to left</strong> It is the order of which operation is done first, not reading from right to left, as one might read Arabic.
</div>


To see what `julia` does we can just check:

```j
2 - 3 - 4
(2 - 3) - 4
2 - (3 - 4)
```

So we see that this was handled in the left to right manner.


### Questions
`r I(page$new_problem("right to left"))`
`r I(page$new_problem("..."))`
`r I(page$new_problem("..."))`
`r I(page$new_problem("Check that /, + and * are associative"))`
<hr/>





### Powers

Not all operations are processed left-to-right. For powers, the order
varies from programming language to programming language. For example:

```j
4^ 3^2
(4^3)^2
4^(3^2)
```

Shows this is done right to left in `julia`. (There is no consistency
here amongst programming languages, but this is how we parse the math
expression $4^3^2$ where the work is done from the top down.)

<span class="label label-info">Gotchas</span>

Look at the output of 
```j
2^3^4
```

Why is it 0? The value of $3^4$ is so large that there would be an
overflow. The size of this number would have roughly this many digits


Which is too large for integer arithmetic which in this case (`Int64`)
is limited to numbers within the range $-2^{63}$ to $2^{63} - 1$.

The following works though:
```j
2.0 ^ 3 ^ 4
```

This is because the value `2.0` will use floating point arithmetic
which has a much wider range of values. (The `julia` documentation
sends you to this interesting blog post
http://www.johndcook.com/blog/2009/04/06/anatomy-of-a-floating-point-number/,
which indicates the largest floating point value is $2^{1023}(2 -
2^{-52})$ which is roughly `1.8e308`.


### Questions

`r I(page$new_problem(""))`
`r I(page$new_problem(""))`
`r I(page$new_problem("check 170! okya, 171! too big"))`

<hr/>


### Trigoonmetric functions

The basic trigonometric functions in `julia` work with radians:

```j
sin(pi/4)
cos(pi/3)
```

But students think in degrees. What to do? Well, you can always convert via the ratio $\pi/180$:

```j
sin(45 * pi/180)
cos(60 * pi/180)
```

However, `julia` provides functions `sind`, `cosd`, and `tand` to work directly with degrees:

```j
sind(45)
cosd(45)
```





`r I(nav$add("Variables"))`


With a calculator, one can store values into a _memory_ for later
usage. This useful feature with calculators is greatly enhanced with
computer languages, where one can bind, or assign, a variable to a
value. For example the command `x=2` will define `x` to have the value $2$:

```j
x = 2
```

So, when we evaluate
```j
x^2
```

The value of `x` is looked up and used to return $4$.


In `julia` one can have single letter names, or much longer ones, such as

```j
some_ridiculously_long_name = 3
some_ridiculously_long_name^2
```



The word "dynamic" refers to the fact that variables can be reassigned
and retyped. For example:

```j
x = sqrt(2) ## a Float64 now
x
```

This is unlike other languages, where the variable type is defined
prior to use so the underlying compiled code can be
optimized. (`Julia` uses a dynamic compiler for speed and
flexibility.)


To work with computer languages, it is important to appreciate that
the equals sign in the variable assignment is unlike that of
mathematics, where often it is used to indicate an equation which may
be solved for a value. With the following computer command the right
hand expression is evaluated and that value is assigned to the
variable. So,

```j
x = 2 + 3
```

does not assign the expression `2 + 3` to `x`, but rather the
evaluation of that expression, which yields 5.


`r I(nav$add("Blocks"))`


At the prompt, a simple expression is entered and, when the *return*
key is pressed, evaluated.  At times we may want to work with multiple
subexpressions. A particular case might be setting different
parameters:

```j
a=0
b=1
c=2
```

Can be more tersely written by separating each expression using a semicolon:

```j
a=0; b=1; c=2
```

One can also separate off "blocks" of expressions using a
`begin`-`end` pair:

```j
begin
  a = 0
  b = 1
  c = 2
end
```

This is more verbose than initially, but many times in `julia` a block
is used and terminated with an `end` statement.



<!--- Finish this off -->
`r I(nav$write_footer())`
`r I(page$write_footer())`

